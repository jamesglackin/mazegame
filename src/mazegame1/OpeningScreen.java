/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package mazegame1;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.WindowEvent;
import java.util.LinkedHashMap;
import javax.swing.JTextField;

/**
 *
 * @author james.glackin
 */
public class OpeningScreen extends javax.swing.JFrame implements KeyListener {

    
    private boolean greenChecked = false;
    private int moveCount;
    private LinkedHashMap<Integer, LinkedHashMap<Integer, Integer>> coordinatesToFill = new LinkedHashMap<>();
    private LinkedHashMap<Integer, LinkedHashMap<Integer, Integer>> emptyCoordinates = new LinkedHashMap<>();
    private LinkedHashMap<Character, LinkedHashMap<Integer, Integer>> otherCoordinates = new LinkedHashMap<>();
    private int[] currentPosition;
    private LinkedHashMap<String, Integer> boundaries = new LinkedHashMap();
    private String difficulty;   
    private boolean ignoreWall = false;
    private boolean greenCollected = false;
    private boolean wallRemoved = false;
    private int heightAndWidth = 50;
    
    
    /**
     * Creates new form OpeningScreen
     */
    public OpeningScreen() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        EasyMazeButton = new javax.swing.JButton();
        MediumMazeButton = new javax.swing.JButton();
        winLabel = new javax.swing.JLabel();
        homeScreen = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jLabel1.setFont(new java.awt.Font("Segoe UI Light", 0, 48)); // NOI18N
        jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel1.setText("Maze Game");

        EasyMazeButton.setText("Easy Maze");
        EasyMazeButton.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                EasyMazeButtonMouseClicked(evt);
            }
        });
        EasyMazeButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                EasyMazeButtonActionPerformed(evt);
            }
        });

        MediumMazeButton.setText("Medium Maze");
        MediumMazeButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                MediumMazeButtonActionPerformed(evt);
            }
        });

        homeScreen.setText("Home Screen");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(200, 200, 200)
                .addComponent(EasyMazeButton)
                .addGap(93, 93, 93)
                .addComponent(MediumMazeButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 775, Short.MAX_VALUE)
                .addComponent(homeScreen)
                .addGap(82, 82, 82))
            .addGroup(layout.createSequentialGroup()
                .addGap(316, 316, 316)
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 300, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(winLabel)
                .addGap(62, 62, 62))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(170, 170, 170)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 132, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(winLabel))
                .addGap(127, 127, 127)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(EasyMazeButton)
                    .addComponent(MediumMazeButton)
                    .addComponent(homeScreen))
                .addContainerGap(691, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void EasyMazeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_EasyMazeButtonActionPerformed
        // TODO add your handling code here:
        
//        this.getContentPane().removeAll();
//        this.repaint();
        
        MazeGame mazeGame = new MazeGame();
        Container container = this.getContentPane();
        
        java.awt.Graphics g = container.getGraphics();
        
        super.paint(g);
        mazeGame.paintComponent(g);
        
//        
//        KeyListener keyListener = new KeyListener() {
//              
//            @Override
//            public void keyTyped(KeyEvent e) {
//            }
//
//            @Override
//            public void keyPressed(KeyEvent e) {
//            }
//
//            @Override
//            public void keyReleased(KeyEvent e) {
//                try {
//                    
//                    if (e.getKeyCode() == KeyEvent.VK_UP) {
//                        int[] pos = mazeGame.getCurrentPosition();
//                        int currentX = pos[0];
//                        int currentY = pos[1];
//
//                        int nextX = currentX;
//                        int nextY = currentY - heightAndWidth;
//
//                        dictateMoves("UP", nextX, nextY, currentX, currentY);
//
//                   } else if (e.getKeyCode() == KeyEvent.VK_DOWN) {
//                        int[] pos = mazeGame.getCurrentPosition();
//                        int currentX = pos[0];
//                        int currentY = pos[1];
//
//                        int nextX = currentX;
//                        int nextY = currentY + heightAndWidth;
//
//                        dictateMoves("DOWN", nextX, nextY, currentX, currentY);
//                   } else if (e.getKeyCode() == KeyEvent.VK_RIGHT) {
//                        int[] pos = mazeGame.getCurrentPosition();
//                        int currentX = pos[0];
//                        int currentY = pos[1];
//
//                        int nextX = currentX + heightAndWidth;
//                        int nextY = currentY;
//
//                        dictateMoves("RIGHT", nextX, nextY, currentX, currentY);
//                   } else if (e.getKeyCode() == KeyEvent.VK_LEFT) {
//                        int[] pos = mazeGame.getCurrentPosition();
//                        int currentX = pos[0];
//                        int currentY = pos[1];
//
//                        int nextX = currentX - heightAndWidth;
//                        int nextY = currentY;
//
//                        dictateMoves("LEFT", nextX, nextY, currentX, currentY);
//                   }
//                e.consume();
//
//                } catch (Exception ex) {
//                } 
//            }  
//            
//            
//        
//        };
        JTextField textField = new JTextField();
//        textField.addKeyListener(keyListener);
//        textField.setSize(new Dimension(100,100));
        container.add(textField, BorderLayout.NORTH);
        mazeGame.pack();
//        mazeGame.setVisible(true);
        

//        game.setFocusable(true);
//        game.setVisible(true);
//        this.dispose();

        

    }//GEN-LAST:event_EasyMazeButtonActionPerformed

    private void MediumMazeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_MediumMazeButtonActionPerformed
        // TODO add your handling code here:
        MazeGame game = new MazeGame();
        game.setFocusable(true);
        game.setVisible(true);
        this.dispose();
    }//GEN-LAST:event_MediumMazeButtonActionPerformed

    private void EasyMazeButtonMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_EasyMazeButtonMouseClicked
        // TODO add your handling code here:

    }//GEN-LAST:event_EasyMazeButtonMouseClicked

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(OpeningScreen.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(OpeningScreen.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(OpeningScreen.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(OpeningScreen.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */        
        
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new OpeningScreen().setVisible(true);
                
            }
        });
    }
    
    
    

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton EasyMazeButton;
    private javax.swing.JButton MediumMazeButton;
    private javax.swing.JButton homeScreen;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel winLabel;
    // End of variables declaration//GEN-END:variables

 
    public void dictateMoves(String direction, int nextX, int nextY, int currentX, int currentY) throws InterruptedException {
        boolean legal = true;
        boolean skipWalls;

        if (isGreenChecked() == false) {
            skipWalls = checkIfGreen(nextX, nextY, currentX, currentY);
            legal = checkMoveIsLegal(nextX, nextY, currentX, currentY, skipWalls);
        } else {
            if (isWallRemoved() == false) {
                legal = checkMoveIsLegal(nextX, nextY, currentX, currentY, true);
                checkIfWallPieceWillBeRemoved(nextX, nextY);
            } else {
                legal = checkMoveIsLegal(nextX, nextY, currentX, currentY, false);
            }
        }

        if (legal) {
            getContentPane();
//            t2.setSize(new Dimension(500,500));
            setVisible(true);
            java.awt.Graphics g = getGraphics();
            paint(g, nextX, nextY, currentX, currentY);
        }
        setMoveCount(getMoveCount() +1);     
        winLabel.setText(Integer.toString(moveCount));
        winLabel.setVisible(true);
        winLabel.setPreferredSize(new Dimension(150, 150));
        winLabel.setFont(new Font("Serif", Font.PLAIN, 45));
        checkIfWon(nextX, nextY);
    }

    public boolean checkIfGreen(int nextX, int nextY, int currentX, int currentY) {
        LinkedHashMap<Character, LinkedHashMap<Integer, Integer>> startAndEndCoordinates = getOtherCoordinates();
        for (Character coordinate : startAndEndCoordinates.keySet()) {
            char sORe = coordinate;
            LinkedHashMap<Integer,Integer> tempXandYCoordinates = startAndEndCoordinates.get(coordinate);
            for (Integer tempCoordinates : tempXandYCoordinates.keySet()) {
                if (sORe == 'C') {
                    if (nextX == tempCoordinates && nextY == tempXandYCoordinates.get(tempCoordinates)) {
                        setIgnoreWall(true);
                        setGreenCollected(true);
                        setGreenChecked(true);
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public void checkIfWallPieceWillBeRemoved(int nextX, int nextY) {
        LinkedHashMap<Integer, LinkedHashMap<Integer, Integer>> usedCoordinates = getCoordinatesToFill();
        for (Integer coordinate : usedCoordinates.keySet()) {
            LinkedHashMap<Integer,Integer> tempXandYCoordinates = usedCoordinates.get(coordinate);
            for (Integer tempCoordinates : tempXandYCoordinates.keySet()) {
                if (tempCoordinates == nextX && tempXandYCoordinates.get(tempCoordinates) == nextY) {
                    setWallRemoved(true);
                    setGreenCollected(false);
                }                                 
            }
        }
    }


    public void checkIfWon(int nextX, int nextY) throws InterruptedException {
        LinkedHashMap<Character, LinkedHashMap<Integer, Integer>> startAndEndCoordinates = getOtherCoordinates();
        for (Character coordinate : startAndEndCoordinates.keySet()) {
            char sORe = coordinate;
            LinkedHashMap<Integer,Integer> tempXandYCoordinates = startAndEndCoordinates.get(coordinate);
            for (Integer tempCoordinates : tempXandYCoordinates.keySet()) {
                if (sORe == 'E') {
                    if (nextX == tempCoordinates && nextY == tempXandYCoordinates.get(tempCoordinates)) {
                        System.out.println("WINNER");
                        winLabel.setText("YOU WIN!");
                        winLabel.setVisible(true);
                        winLabel.setPreferredSize(new Dimension(150, 150));
                        winLabel.setFont(new Font("Serif", Font.PLAIN, 45));
                        homeScreen.setVisible(true);
                    }
                }
            }
        }
    }

    public boolean checkMoveIsLegal(int nextX, int nextY, int currentX, int currentY, boolean skipWalls) {
        boolean legal = true;
        LinkedHashMap<Integer, LinkedHashMap<Integer, Integer>> usedCoordinates = getCoordinatesToFill();

        if (!skipWalls) {
            for (Integer coordinate : usedCoordinates.keySet()) {
                LinkedHashMap<Integer,Integer> tempXandYCoordinates = usedCoordinates.get(coordinate);
                for (Integer tempCoordinates : tempXandYCoordinates.keySet()) {
                    if (tempCoordinates == nextX && tempXandYCoordinates.get(tempCoordinates) == nextY) {
                        legal = false;
                    }                                 
                }
            }
        }
        LinkedHashMap<String,Integer> boundaries = getBoundaries();

        if ((boundaries.get("Left") > nextX) || (boundaries.get("Top") > nextY) ||
            (boundaries.get("Right") < nextX) || (boundaries.get("Bottom") < nextY)) {
            legal = false;
        }

        System.out.println((boundaries.get("Left").toString()));
        System.out.println("X = " + nextX);
        System.out.println("Y = " + nextY);

        return legal;
    }

    public void paint(java.awt.Graphics g, int nextX, int nextY, int currentX, int currentY) {

        int[] currentPos = {nextX,nextY};
        setCurrentPosition(currentPos);


        g.setColor(Color.WHITE);

        g.fillRect(currentX, currentY, heightAndWidth, heightAndWidth);
        g.setColor(Color.BLACK);
        g.drawRect(currentX, currentY, heightAndWidth, heightAndWidth);
//                g.fillRect(currentX, currentY, 50, 50);

        g.setColor(Color.RED);
        g.drawRect(nextX, nextY, heightAndWidth, heightAndWidth);
        g.fillRect(nextX, nextY, heightAndWidth, heightAndWidth);
    }
    
    
    @Override
    public void keyTyped(KeyEvent e) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void keyPressed(KeyEvent e) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void keyReleased(KeyEvent e) {
        try {
                    
            if (e.getKeyCode() == KeyEvent.VK_UP) {
                int[] pos = getCurrentPosition();
                int currentX = pos[0];
                int currentY = pos[1];

                int nextX = currentX;
                int nextY = currentY - heightAndWidth;

                dictateMoves("UP", nextX, nextY, currentX, currentY);

           } else if (e.getKeyCode() == KeyEvent.VK_DOWN) {
                int[] pos = getCurrentPosition();
                int currentX = pos[0];
                int currentY = pos[1];

                int nextX = currentX;
                int nextY = currentY + heightAndWidth;

                dictateMoves("DOWN", nextX, nextY, currentX, currentY);
           } else if (e.getKeyCode() == KeyEvent.VK_RIGHT) {
                int[] pos = getCurrentPosition();
                int currentX = pos[0];
                int currentY = pos[1];

                int nextX = currentX + heightAndWidth;
                int nextY = currentY;

                dictateMoves("RIGHT", nextX, nextY, currentX, currentY);
           } else if (e.getKeyCode() == KeyEvent.VK_LEFT) {
                int[] pos = getCurrentPosition();
                int currentX = pos[0];
                int currentY = pos[1];

                int nextX = currentX - heightAndWidth;
                int nextY = currentY;

                dictateMoves("LEFT", nextX, nextY, currentX, currentY);
           }
        e.consume();

        } catch (Exception ex) {
        } 
    }
    public void setCurrentPosition(int[] currentPosition) {
        this.currentPosition = currentPosition;
    }
    
    public int[] getCurrentPosition() {
        return currentPosition;
    }
 
     public LinkedHashMap<Character, LinkedHashMap<Integer, Integer>> getOtherCoordinates() {
         return otherCoordinates;
     }

     public void setOtherCoordinates(LinkedHashMap<Character, LinkedHashMap<Integer, Integer>> otherCoordinates) {
         this.otherCoordinates = otherCoordinates;
     }


     public LinkedHashMap<Integer, LinkedHashMap<Integer, Integer>> getCoordinatesToFill() {
         return coordinatesToFill;
     }

     public void setCoordinatesToFill(LinkedHashMap<Integer, LinkedHashMap<Integer, Integer>> coordinatesToFill) {
         this.coordinatesToFill = coordinatesToFill;
     }

     public LinkedHashMap<Integer, LinkedHashMap<Integer, Integer>> getEmptyCoordinates() {
         return emptyCoordinates;
     }

     public void setEmptyCoordinates(LinkedHashMap<Integer, LinkedHashMap<Integer, Integer>> emptyCoordinates) {
         this.emptyCoordinates = emptyCoordinates;
     }
     
     
    public LinkedHashMap<String, Integer> getBoundaries() {
        return boundaries;
    }

    public void setBoundaries(LinkedHashMap<String, Integer> boundaries) {
        this.boundaries = boundaries;
    }
    
    
    public int getMoveCount() {
        return moveCount;
    }

    public void setMoveCount(int moveCount) {
        this.moveCount = moveCount;
    }
    
    
    public String getDifficulty() {
        return difficulty;
    }

    public void setDifficulty(String difficulty) {
        this.difficulty = difficulty;
    }
    
    public boolean isIgnoreWall() {
        return ignoreWall;
    }

    public void setIgnoreWall(boolean ignoreWall) {
        this.ignoreWall = ignoreWall;
    }
    
    public boolean isGreenCollected() {
        return greenCollected;
    }

    public void setGreenCollected(boolean greenCollected) {
        this.greenCollected = greenCollected;
    }
    
  
    public boolean isWallRemoved() {
        return wallRemoved;
    }

    public void setWallRemoved(boolean wallRemoved) {
        this.wallRemoved = wallRemoved;
    }

    public boolean isGreenChecked() {
        return greenChecked;
    }

    public void setGreenChecked(boolean greenChecked) {
        this.greenChecked = greenChecked;
    }
    
    
}

