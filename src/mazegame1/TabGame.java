/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package mazegame1;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.LinkedHashMap;
import javax.swing.JPanel;
import javax.swing.JTabbedPane;
import javax.swing.JTextField;

/**
 *
 * @author james.glackin
 */
public class TabGame extends javax.swing.JFrame implements KeyListener {

    /**
     * Creates new form TabGame
     */
    public TabGame() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        TabbedPanel = new javax.swing.JTabbedPane();
        EasyPanel = new javax.swing.JPanel();
        MediumPanel = new javax.swing.JPanel();
        HardPanel = new javax.swing.JTabbedPane();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        TabbedPanel.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                TabbedPanelStateChanged(evt);
            }
        });

        javax.swing.GroupLayout EasyPanelLayout = new javax.swing.GroupLayout(EasyPanel);
        EasyPanel.setLayout(EasyPanelLayout);
        EasyPanelLayout.setHorizontalGroup(
            EasyPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1806, Short.MAX_VALUE)
        );
        EasyPanelLayout.setVerticalGroup(
            EasyPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1128, Short.MAX_VALUE)
        );

        TabbedPanel.addTab("Easy", EasyPanel);

        javax.swing.GroupLayout MediumPanelLayout = new javax.swing.GroupLayout(MediumPanel);
        MediumPanel.setLayout(MediumPanelLayout);
        MediumPanelLayout.setHorizontalGroup(
            MediumPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1806, Short.MAX_VALUE)
        );
        MediumPanelLayout.setVerticalGroup(
            MediumPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1128, Short.MAX_VALUE)
        );

        TabbedPanel.addTab("Medium", MediumPanel);
        TabbedPanel.addTab("Hard", HardPanel);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(TabbedPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 1811, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(TabbedPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 1162, Short.MAX_VALUE)
        );

        TabbedPanel.getAccessibleContext().setAccessibleName("Easy");

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void TabbedPanelStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_TabbedPanelStateChanged
        // TODO add your handling code here:

//        this.pack();

        if (tabChangesCount == 0) { 
            
        } else {
            this.setVisible(true);
            int selectedTab = TabbedPanel.getSelectedIndex();
            String difficulty = "";
            Graphics g = this.getGraphics();
            Container container = this.getParent();

            TestPanel testPanel = new TestPanel();
            switch (selectedTab) {
                case 0:
                    testPanel.paintComponent(g);
                    break;
                case 1:
                    testPanel.paintComponent(g);
                    break;
                case 2:
                    
                    break;
            }
            
        }
        tabChangesCount ++;
    }//GEN-LAST:event_TabbedPanelStateChanged

    /**
     * @param args the command line arguments
     */
        
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel EasyPanel;
    private javax.swing.JTabbedPane HardPanel;
    private javax.swing.JPanel MediumPanel;
    private javax.swing.JTabbedPane TabbedPanel;
    // End of variables declaration//GEN-END:variables


    // Variables declaration - do not modify                     
    private javax.swing.JButton homeScreen;
    private javax.swing.JLabel winLabel;
    // End of variables declaration                   

    private boolean greenChecked = false;
    private int moveCount;
    private LinkedHashMap<Integer, LinkedHashMap<Integer, Integer>> coordinatesToFill = new LinkedHashMap<>();
    private LinkedHashMap<Integer, LinkedHashMap<Integer, Integer>> emptyCoordinates = new LinkedHashMap<>();
    private LinkedHashMap<Character, LinkedHashMap<Integer, Integer>> otherCoordinates = new LinkedHashMap<>();
    private int[] currentPosition;
    private LinkedHashMap<String, Integer> boundaries = new LinkedHashMap();
    private String difficulty;   
    private boolean ignoreWall = false;
    private boolean greenCollected = false;
    private boolean wallRemoved = false;
    private int heightAndWidth = 50;
    
    private int tabChangesCount = 0;

    @SuppressWarnings("unchecked")
   
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(MazeGame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(MazeGame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(MazeGame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(MazeGame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        
//        java.awt.EventQueue.invokeLater(new Runnable() {
//            public void run() {
//                new TabGame().setVisible(true);
//                
//            }
//        });

        TabGame tabGame = new TabGame();;
//        mazeScreen.setVisible(true);
        Container container = tabGame.getContentPane(); 
        
        KeyListener keyListener = new KeyListener() {
            @Override
            public void keyTyped(KeyEvent e) {
            }

            @Override
            public void keyPressed(KeyEvent e) {
            }

            @Override
            public void keyReleased(KeyEvent e) {
                try {
                    
                    if (e.getKeyCode() == KeyEvent.VK_UP) {
                        int[] pos = tabGame.getCurrentPosition();
                        int currentX = pos[0];
                        int currentY = pos[1];

                        int nextX = currentX;
                        int nextY = currentY - tabGame.heightAndWidth;

                        dictateMoves("UP", nextX, nextY, currentX, currentY);

                   } else if (e.getKeyCode() == KeyEvent.VK_DOWN) {
                        int[] pos = tabGame.getCurrentPosition();
                        int currentX = pos[0];
                        int currentY = pos[1];

                        int nextX = currentX;
                        int nextY = currentY + tabGame.heightAndWidth;

                        dictateMoves("DOWN", nextX, nextY, currentX, currentY);
                   } else if (e.getKeyCode() == KeyEvent.VK_RIGHT) {
                        int[] pos = tabGame.getCurrentPosition();
                        int currentX = pos[0];
                        int currentY = pos[1];

                        int nextX = currentX + tabGame.heightAndWidth;
                        int nextY = currentY;

                        dictateMoves("RIGHT", nextX, nextY, currentX, currentY);
                   } else if (e.getKeyCode() == KeyEvent.VK_LEFT) {
                        int[] pos = tabGame.getCurrentPosition();
                        int currentX = pos[0];
                        int currentY = pos[1];

                        int nextX = currentX - tabGame.heightAndWidth;
                        int nextY = currentY;

                        dictateMoves("LEFT", nextX, nextY, currentX, currentY);
                   }
                e.consume();

                } catch (Exception ex) {
                } 
            }  
            
            public void dictateMoves(String direction, int nextX, int nextY, int currentX, int currentY) throws InterruptedException {
                boolean legal = true;
                boolean skipWalls;
                                
                if (tabGame.isGreenChecked() == false) {
                    skipWalls = checkIfGreen(nextX, nextY, currentX, currentY);
                    legal = checkMoveIsLegal(nextX, nextY, currentX, currentY, skipWalls);
                } else {
                    if (tabGame.isWallRemoved() == false) {
                        legal = checkMoveIsLegal(nextX, nextY, currentX, currentY, true);
                        checkIfWallPieceWillBeRemoved(nextX, nextY);
                    } else {
                        legal = checkMoveIsLegal(nextX, nextY, currentX, currentY, false);
                    }
                }
                
                if (legal) {
                    tabGame.getContentPane();
        //            t2.setSize(new Dimension(500,500));
                    tabGame.setVisible(true);
                    Graphics g = tabGame.getGraphics();
                    paint(g, nextX, nextY, currentX, currentY);
                }
                tabGame.setMoveCount(tabGame.getMoveCount() +1);     
                tabGame.winLabel.setText(Integer.toString(tabGame.moveCount));
                tabGame.winLabel.setVisible(true);
                tabGame.winLabel.setPreferredSize(new Dimension(150, 150));
                tabGame.winLabel.setFont(new Font("Serif", Font.PLAIN, 45));
                checkIfWon(nextX, nextY);
            }
            
            public boolean checkIfGreen(int nextX, int nextY, int currentX, int currentY) {
                LinkedHashMap<Character, LinkedHashMap<Integer, Integer>> startAndEndCoordinates = tabGame.getOtherCoordinates();
                for (Character coordinate : startAndEndCoordinates.keySet()) {
                    char sORe = coordinate;
                    LinkedHashMap<Integer,Integer> tempXandYCoordinates = startAndEndCoordinates.get(coordinate);
                    for (Integer tempCoordinates : tempXandYCoordinates.keySet()) {
                        if (sORe == 'C') {
                            if (nextX == tempCoordinates && nextY == tempXandYCoordinates.get(tempCoordinates)) {
                                tabGame.setIgnoreWall(true);
                                tabGame.setGreenCollected(true);
                                tabGame.setGreenChecked(true);
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            public void checkIfWallPieceWillBeRemoved(int nextX, int nextY) {
                LinkedHashMap<Integer, LinkedHashMap<Integer, Integer>> usedCoordinates = tabGame.getCoordinatesToFill();
                for (Integer coordinate : usedCoordinates.keySet()) {
                    LinkedHashMap<Integer,Integer> tempXandYCoordinates = usedCoordinates.get(coordinate);
                    for (Integer tempCoordinates : tempXandYCoordinates.keySet()) {
                        if (tempCoordinates == nextX && tempXandYCoordinates.get(tempCoordinates) == nextY) {
                            tabGame.setWallRemoved(true);
                            tabGame.setGreenCollected(false);
                        }                                 
                    }
                }
            }
            
            
            public void checkIfWon(int nextX, int nextY) throws InterruptedException {
                LinkedHashMap<Character, LinkedHashMap<Integer, Integer>> startAndEndCoordinates = tabGame.getOtherCoordinates();
                for (Character coordinate : startAndEndCoordinates.keySet()) {
                    char sORe = coordinate;
                    LinkedHashMap<Integer,Integer> tempXandYCoordinates = startAndEndCoordinates.get(coordinate);
                    for (Integer tempCoordinates : tempXandYCoordinates.keySet()) {
                        if (sORe == 'E') {
                            if (nextX == tempCoordinates && nextY == tempXandYCoordinates.get(tempCoordinates)) {
                                System.out.println("WINNER");
                                tabGame.winLabel.setText("YOU WIN!");
                                tabGame.winLabel.setVisible(true);
                                tabGame.winLabel.setPreferredSize(new Dimension(150, 150));
                                tabGame.winLabel.setFont(new Font("Serif", Font.PLAIN, 45));
                                tabGame.homeScreen.setVisible(true);
                            }
                        }
                    }
                }
            }
             
            public boolean checkMoveIsLegal(int nextX, int nextY, int currentX, int currentY, boolean skipWalls) {
                boolean legal = true;
                LinkedHashMap<Integer, LinkedHashMap<Integer, Integer>> usedCoordinates = tabGame.getCoordinatesToFill();
                
                if (!skipWalls) {
                    for (Integer coordinate : usedCoordinates.keySet()) {
                        LinkedHashMap<Integer,Integer> tempXandYCoordinates = usedCoordinates.get(coordinate);
                        for (Integer tempCoordinates : tempXandYCoordinates.keySet()) {
                            if (tempCoordinates == nextX && tempXandYCoordinates.get(tempCoordinates) == nextY) {
                                legal = false;
                            }                                 
                        }
                    }
                }
                LinkedHashMap<String,Integer> boundaries = tabGame.getBoundaries();

                if ((boundaries.get("Left") > nextX) || (boundaries.get("Top") > nextY) ||
                    (boundaries.get("Right") < nextX) || (boundaries.get("Bottom") < nextY)) {
                    legal = false;
                }
                
                System.out.println((boundaries.get("Left").toString()));
                System.out.println("X = " + nextX);
                System.out.println("Y = " + nextY);
                     
                return legal;
            }
            
            public void paint(Graphics g, int nextX, int nextY, int currentX, int currentY) {
                
                int[] currentPos = {nextX,nextY};
                tabGame.setCurrentPosition(currentPos);
                
                
                g.setColor(Color.WHITE);
                
                g.fillRect(currentX, currentY, tabGame.heightAndWidth, tabGame.heightAndWidth);
                g.setColor(Color.BLACK);
                g.drawRect(currentX, currentY, tabGame.heightAndWidth, tabGame.heightAndWidth);
//                g.fillRect(currentX, currentY, 50, 50);
                
                g.setColor(Color.RED);
                g.drawRect(nextX, nextY, tabGame.heightAndWidth, tabGame.heightAndWidth);
                g.fillRect(nextX, nextY, tabGame.heightAndWidth, tabGame.heightAndWidth);
            }
        
        };
        JTextField textField = new JTextField();
        textField.addKeyListener(keyListener);
//        textField.setSize(new Dimension(100,100));
        container.add(textField, BorderLayout.NORTH);
        tabGame.pack();
        tabGame.setSize(new Dimension(1811, 1162));
        tabGame.setVisible(true);
    }
    
    public void setCurrentPosition(int[] currentPosition) {
        this.currentPosition = currentPosition;
    }
    
    public int[] getCurrentPosition() {
        return currentPosition;
    }
 
     public LinkedHashMap<Character, LinkedHashMap<Integer, Integer>> getOtherCoordinates() {
         return otherCoordinates;
     }

     public void setOtherCoordinates(LinkedHashMap<Character, LinkedHashMap<Integer, Integer>> otherCoordinates) {
         this.otherCoordinates = otherCoordinates;
     }


     public LinkedHashMap<Integer, LinkedHashMap<Integer, Integer>> getCoordinatesToFill() {
         return coordinatesToFill;
     }

     public void setCoordinatesToFill(LinkedHashMap<Integer, LinkedHashMap<Integer, Integer>> coordinatesToFill) {
         this.coordinatesToFill = coordinatesToFill;
     }

     public LinkedHashMap<Integer, LinkedHashMap<Integer, Integer>> getEmptyCoordinates() {
         return emptyCoordinates;
     }

     public void setEmptyCoordinates(LinkedHashMap<Integer, LinkedHashMap<Integer, Integer>> emptyCoordinates) {
         this.emptyCoordinates = emptyCoordinates;
     }
     
     
    public LinkedHashMap<String, Integer> getBoundaries() {
        return boundaries;
    }

    public void setBoundaries(LinkedHashMap<String, Integer> boundaries) {
        this.boundaries = boundaries;
    }
    
    
    public int getMoveCount() {
        return moveCount;
    }

    public void setMoveCount(int moveCount) {
        this.moveCount = moveCount;
    }
    
    
    public String getDifficulty() {
        return difficulty;
    }

    public void setDifficulty(String difficulty) {
        this.difficulty = difficulty;
    }
    
    public boolean isIgnoreWall() {
        return ignoreWall;
    }

    public void setIgnoreWall(boolean ignoreWall) {
        this.ignoreWall = ignoreWall;
    }
    
    public boolean isGreenCollected() {
        return greenCollected;
    }

    public void setGreenCollected(boolean greenCollected) {
        this.greenCollected = greenCollected;
    }
    
  
    public boolean isWallRemoved() {
        return wallRemoved;
    }

    public void setWallRemoved(boolean wallRemoved) {
        this.wallRemoved = wallRemoved;
    }

    public boolean isGreenChecked() {
        return greenChecked;
    }

    public void setGreenChecked(boolean greenChecked) {
        this.greenChecked = greenChecked;
    }

    @Override
    public void keyTyped(KeyEvent e) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void keyPressed(KeyEvent e) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void keyReleased(KeyEvent e) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    
}
