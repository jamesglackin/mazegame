/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package mazegame1;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.LinkedHashMap;
import javax.swing.JTextField;

/**
 *
 * @author james.glackin
 */
public class TestPanel extends javax.swing.JPanel implements KeyListener {
    /**
     * Creates new form TestPanel
     */
    public TestPanel() {
        initComponents();
    }
    
    private boolean greenChecked = false;
    private int moveCount;
    private LinkedHashMap<Integer, LinkedHashMap<Integer, Integer>> coordinatesToFill = new LinkedHashMap<>();
    private LinkedHashMap<Integer, LinkedHashMap<Integer, Integer>> emptyCoordinates = new LinkedHashMap<>();
    private LinkedHashMap<Character, LinkedHashMap<Integer, Integer>> otherCoordinates = new LinkedHashMap<>();
    private int[] currentPosition;
    private LinkedHashMap<String, Integer> boundaries = new LinkedHashMap();
    private String difficulty;   
    private boolean ignoreWall = false;
    private boolean greenCollected = false;
    private boolean wallRemoved = false;
    private int heightAndWidth = 50;

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        homeScreen = new javax.swing.JButton();
        winLabel = new javax.swing.JLabel();

        homeScreen.setText("Home Screen");
        homeScreen.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                homeScreenActionPerformed(evt);
            }
        });

        winLabel.setToolTipText("");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap(1394, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(homeScreen)
                        .addGap(42, 42, 42))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(winLabel)
                        .addGap(103, 103, 103))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(150, 150, 150)
                .addComponent(winLabel)
                .addGap(342, 342, 342)
                .addComponent(homeScreen)
                .addContainerGap(650, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

    private void homeScreenActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_homeScreenActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_homeScreenActionPerformed

    
    public static void main(String[] args) {
        TestPanel testPanel = new TestPanel();
        Container container = testPanel.getParent();
        KeyListener keyListener = new KeyListener() {
            @Override
            public void keyTyped(KeyEvent e) {
            }

            @Override
            public void keyPressed(KeyEvent e) {
            }

            @Override
            public void keyReleased(KeyEvent e) {
                try {
                    
                    if (e.getKeyCode() == KeyEvent.VK_UP) {
                        int[] pos = testPanel.getCurrentPosition();
                        int currentX = pos[0];
                        int currentY = pos[1];

                        int nextX = currentX;
                        int nextY = currentY - testPanel.heightAndWidth;

                        dictateMoves("UP", nextX, nextY, currentX, currentY);

                   } else if (e.getKeyCode() == KeyEvent.VK_DOWN) {
                        int[] pos = testPanel.getCurrentPosition();
                        int currentX = pos[0];
                        int currentY = pos[1];

                        int nextX = currentX;
                        int nextY = currentY + testPanel.heightAndWidth;

                        dictateMoves("DOWN", nextX, nextY, currentX, currentY);
                   } else if (e.getKeyCode() == KeyEvent.VK_RIGHT) {
                        int[] pos = testPanel.getCurrentPosition();
                        int currentX = pos[0];
                        int currentY = pos[1];

                        int nextX = currentX + testPanel.heightAndWidth;
                        int nextY = currentY;

                        dictateMoves("RIGHT", nextX, nextY, currentX, currentY);
                   } else if (e.getKeyCode() == KeyEvent.VK_LEFT) {
                        int[] pos = testPanel.getCurrentPosition();
                        int currentX = pos[0];
                        int currentY = pos[1];

                        int nextX = currentX - testPanel.heightAndWidth;
                        int nextY = currentY;

                        dictateMoves("LEFT", nextX, nextY, currentX, currentY);
                   }
                e.consume();

                } catch (Exception ex) {
                } 
            } 
             public void dictateMoves(String direction, int nextX, int nextY, int currentX, int currentY) throws InterruptedException {
                boolean legal = true;
                boolean skipWalls;
                                
                if (testPanel.isGreenChecked() == false) {
                    skipWalls = checkIfGreen(nextX, nextY, currentX, currentY);
                    legal = checkMoveIsLegal(nextX, nextY, currentX, currentY, skipWalls);
                } else {
                    if (testPanel.isWallRemoved() == false) {
                        legal = checkMoveIsLegal(nextX, nextY, currentX, currentY, true);
                        checkIfWallPieceWillBeRemoved(nextX, nextY);
                    } else {
                        legal = checkMoveIsLegal(nextX, nextY, currentX, currentY, false);
                    }
                }
                
                if (legal) {
                    testPanel.getParent();
        //            t2.setSize(new Dimension(500,500));
                    testPanel.setVisible(true);
                    Graphics g = testPanel.getGraphics();
                    paint(g, nextX, nextY, currentX, currentY);
                }
                testPanel.setMoveCount(testPanel.getMoveCount() +1);     
                testPanel.winLabel.setText(Integer.toString(testPanel.moveCount));
                testPanel.winLabel.setVisible(true);
                testPanel.winLabel.setPreferredSize(new Dimension(150, 150));
                testPanel.winLabel.setFont(new Font("Serif", Font.PLAIN, 45));
                checkIfWon(nextX, nextY);
            }
            
            public boolean checkIfGreen(int nextX, int nextY, int currentX, int currentY) {
                LinkedHashMap<Character, LinkedHashMap<Integer, Integer>> startAndEndCoordinates = testPanel.getOtherCoordinates();
                for (Character coordinate : startAndEndCoordinates.keySet()) {
                    char sORe = coordinate;
                    LinkedHashMap<Integer,Integer> tempXandYCoordinates = startAndEndCoordinates.get(coordinate);
                    for (Integer tempCoordinates : tempXandYCoordinates.keySet()) {
                        if (sORe == 'C') {
                            if (nextX == tempCoordinates && nextY == tempXandYCoordinates.get(tempCoordinates)) {
                                testPanel.setIgnoreWall(true);
                                testPanel.setGreenCollected(true);
                                testPanel.setGreenChecked(true);
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            public void checkIfWallPieceWillBeRemoved(int nextX, int nextY) {
                LinkedHashMap<Integer, LinkedHashMap<Integer, Integer>> usedCoordinates = testPanel.getCoordinatesToFill();
                for (Integer coordinate : usedCoordinates.keySet()) {
                    LinkedHashMap<Integer,Integer> tempXandYCoordinates = usedCoordinates.get(coordinate);
                    for (Integer tempCoordinates : tempXandYCoordinates.keySet()) {
                        if (tempCoordinates == nextX && tempXandYCoordinates.get(tempCoordinates) == nextY) {
                            testPanel.setWallRemoved(true);
                            testPanel.setGreenCollected(false);
                        }                                 
                    }
                }
            }
            
            
            public void checkIfWon(int nextX, int nextY) throws InterruptedException {
                LinkedHashMap<Character, LinkedHashMap<Integer, Integer>> startAndEndCoordinates = testPanel.getOtherCoordinates();
                for (Character coordinate : startAndEndCoordinates.keySet()) {
                    char sORe = coordinate;
                    LinkedHashMap<Integer,Integer> tempXandYCoordinates = startAndEndCoordinates.get(coordinate);
                    for (Integer tempCoordinates : tempXandYCoordinates.keySet()) {
                        if (sORe == 'E') {
                            if (nextX == tempCoordinates && nextY == tempXandYCoordinates.get(tempCoordinates)) {
                                System.out.println("WINNER");
                                testPanel.winLabel.setText("YOU WIN!");
                                testPanel.winLabel.setVisible(true);
                                testPanel.winLabel.setPreferredSize(new Dimension(150, 150));
                                testPanel.winLabel.setFont(new Font("Serif", Font.PLAIN, 45));
                                testPanel.homeScreen.setVisible(true);
                            }
                        }
                    }
                }
            }
             
            public boolean checkMoveIsLegal(int nextX, int nextY, int currentX, int currentY, boolean skipWalls) {
                boolean legal = true;
                LinkedHashMap<Integer, LinkedHashMap<Integer, Integer>> usedCoordinates = testPanel.getCoordinatesToFill();
                
                if (!skipWalls) {
                    for (Integer coordinate : usedCoordinates.keySet()) {
                        LinkedHashMap<Integer,Integer> tempXandYCoordinates = usedCoordinates.get(coordinate);
                        for (Integer tempCoordinates : tempXandYCoordinates.keySet()) {
                            if (tempCoordinates == nextX && tempXandYCoordinates.get(tempCoordinates) == nextY) {
                                legal = false;
                            }                                 
                        }
                    }
                }
                LinkedHashMap<String,Integer> boundaries = testPanel.getBoundaries();

                if ((boundaries.get("Left") > nextX) || (boundaries.get("Top") > nextY) ||
                    (boundaries.get("Right") < nextX) || (boundaries.get("Bottom") < nextY)) {
                    legal = false;
                }
                
                System.out.println((boundaries.get("Left").toString()));
                System.out.println("X = " + nextX);
                System.out.println("Y = " + nextY);
                     
                return legal;
            }
            
            public void paint(Graphics g, int nextX, int nextY, int currentX, int currentY) {
                
                int[] currentPos = {nextX,nextY};
                testPanel.setCurrentPosition(currentPos);
                
                
                g.setColor(Color.WHITE);
                
                g.fillRect(currentX, currentY, testPanel.heightAndWidth, testPanel.heightAndWidth);
                g.setColor(Color.BLACK);
                g.drawRect(currentX, currentY, testPanel.heightAndWidth, testPanel.heightAndWidth);
//                g.fillRect(currentX, currentY, 50, 50);
                
                g.setColor(Color.RED);
                g.drawRect(nextX, nextY, testPanel.heightAndWidth, testPanel.heightAndWidth);
                g.fillRect(nextX, nextY, testPanel.heightAndWidth, testPanel.heightAndWidth);
            }
        
        };
        JTextField textField = new JTextField();
        textField.addKeyListener(keyListener);
//        textField.setSize(new Dimension(100,100));
        container.add(textField, BorderLayout.NORTH);
//        testPanel.pack();
        testPanel.setVisible(true);
        };
    
    public LinkedHashMap<Integer, LinkedHashMap<Integer,Integer>> create() {
        try {
            
//            FileReader fileReader = new FileReader("C:\\DataGenic\\Apprentice\\Project\\Maze\\maze_" + difficulty + ".txt");

            FileReader fileReader = new FileReader("C:\\DataGenic\\Apprentice\\Project\\Maze\\maze_easy.txt");
            
            // C:\DataGenic\Apprentice\Project\Maze\maze_medium.txt
            // maze_easy
            
            BufferedReader bufferedReader = new BufferedReader(fileReader);
            String line;
            int yAxis = 100;
            int count = 0;
            setMoveCount(0);
            LinkedHashMap<String, Integer> boundaries = new LinkedHashMap();            
            boundaries.put("Left", 150);
            boundaries.put("Top", yAxis);

            while ((line = bufferedReader.readLine()) != null) {
                String[] letters = line.split("-");
                int length = (letters.length * heightAndWidth) + 100;
                int xAxis = 150;
                boundaries.put("Right", length-heightAndWidth);

                do {
                    for (String letter : letters) {
                        LinkedHashMap<Integer,Integer> tempXandYCoordinates = new LinkedHashMap<>();
                        if (letter.equals("B")) {
                            tempXandYCoordinates.put(xAxis,yAxis);
                            emptyCoordinates.put(count,tempXandYCoordinates);
                        } else if (letter.equals("W")) {
                            tempXandYCoordinates.put(xAxis,yAxis);
                            coordinatesToFill.put(count,tempXandYCoordinates);
                        } else if (letter.equals("S")) {
                            tempXandYCoordinates.put(xAxis,yAxis);
                            otherCoordinates.put('S', tempXandYCoordinates);
                        } else if (letter.equals("E")) {
                            tempXandYCoordinates.put(xAxis,yAxis);
                            otherCoordinates.put('E', tempXandYCoordinates);
                        } else if (letter.equals("C")) {
                            tempXandYCoordinates.put(xAxis,yAxis);
                            otherCoordinates.put('C', tempXandYCoordinates);
                        } else {
                        }
                        if (letter.equals(",")) {
                            yAxis += heightAndWidth;
                        }
                        if (xAxis == length) {
                            break;
                        }
                        xAxis += heightAndWidth;
                        count ++;
                    }
                } while (xAxis != length);
                boundaries.put("Bottom", yAxis-heightAndWidth);
            }
            setOtherCoordinates(otherCoordinates);
            setEmptyCoordinates(emptyCoordinates);
            setBoundaries(boundaries);            
            return coordinatesToFill;
        } catch (Exception e) {

        }
        return coordinatesToFill;
    }
    
    //String difficulty, Graphics g
    public void paintComponent(Graphics g) {
        LinkedHashMap<Integer, LinkedHashMap<Integer,Integer>> coordinatesToFill = create();  
        LinkedHashMap<Integer, LinkedHashMap<Integer,Integer>> emptyCoordinates = getEmptyCoordinates();
        LinkedHashMap<Character, LinkedHashMap<Integer,Integer>> startAndEndCoordinates = getOtherCoordinates();
        
        for (Integer coordinate : coordinatesToFill.keySet()) {
            LinkedHashMap<Integer,Integer> tempXandYCoordinates = coordinatesToFill.get(coordinate);
            for (Integer tempCoordinates : tempXandYCoordinates.keySet()) {
                g.drawRect(tempCoordinates, tempXandYCoordinates.get(tempCoordinates),heightAndWidth,heightAndWidth);
                g.setColor(Color.BLACK);
                g.fillRect(tempCoordinates, tempXandYCoordinates.get(tempCoordinates),heightAndWidth,heightAndWidth);
            }
        }

        for (Integer coordinate : emptyCoordinates.keySet()) {
            LinkedHashMap<Integer,Integer> tempXandYCoordinates = emptyCoordinates.get(coordinate);
            for (Integer tempCoordinates : tempXandYCoordinates.keySet()) {
                g.setColor(Color.BLACK);
                g.drawRect(tempCoordinates, tempXandYCoordinates.get(tempCoordinates),heightAndWidth,heightAndWidth);
            }
        }

        for (Character coordinate : startAndEndCoordinates.keySet()) {
            char sORe = coordinate;
            LinkedHashMap<Integer,Integer> tempXandYCoordinates = startAndEndCoordinates.get(coordinate);
            for (Integer tempCoordinates : tempXandYCoordinates.keySet()) {
                g.drawRect(tempCoordinates, tempXandYCoordinates.get(tempCoordinates),heightAndWidth,heightAndWidth);
                if (sORe == 'S') {
                    g.setColor(Color.RED);
                    g.fillRect(tempCoordinates, tempXandYCoordinates.get(tempCoordinates),heightAndWidth,heightAndWidth);
                    int[] currentPos = {tempCoordinates, tempXandYCoordinates.get(tempCoordinates)};
                    setCurrentPosition(currentPos);
                } else if (sORe == 'E') {
                    g.setColor(Color.BLUE);
                    g.fillRect(tempCoordinates, tempXandYCoordinates.get(tempCoordinates),heightAndWidth,heightAndWidth);
                } else if (sORe == 'C') {
                    g.setColor(Color.GREEN);
                    g.fillRect(tempCoordinates, tempXandYCoordinates.get(tempCoordinates),heightAndWidth,heightAndWidth);
                }
            }
        }
//        String[] s = null;
//        main(s);
    }

    public void setCurrentPosition(int[] currentPosition) {
        this.currentPosition = currentPosition;
    }
    
    public int[] getCurrentPosition() {
        return currentPosition;
    }
 
     public LinkedHashMap<Character, LinkedHashMap<Integer, Integer>> getOtherCoordinates() {
         return otherCoordinates;
     }

     public void setOtherCoordinates(LinkedHashMap<Character, LinkedHashMap<Integer, Integer>> otherCoordinates) {
         this.otherCoordinates = otherCoordinates;
     }


     public LinkedHashMap<Integer, LinkedHashMap<Integer, Integer>> getCoordinatesToFill() {
         return coordinatesToFill;
     }

     public void setCoordinatesToFill(LinkedHashMap<Integer, LinkedHashMap<Integer, Integer>> coordinatesToFill) {
         this.coordinatesToFill = coordinatesToFill;
     }

     public LinkedHashMap<Integer, LinkedHashMap<Integer, Integer>> getEmptyCoordinates() {
         return emptyCoordinates;
     }

     public void setEmptyCoordinates(LinkedHashMap<Integer, LinkedHashMap<Integer, Integer>> emptyCoordinates) {
         this.emptyCoordinates = emptyCoordinates;
     }
     
     
    public LinkedHashMap<String, Integer> getBoundaries() {
        return boundaries;
    }

    public void setBoundaries(LinkedHashMap<String, Integer> boundaries) {
        this.boundaries = boundaries;
    }
    
    
    public int getMoveCount() {
        return moveCount;
    }

    public void setMoveCount(int moveCount) {
        this.moveCount = moveCount;
    }
    
    
    public String getDifficulty() {
        return difficulty;
    }

    public void setDifficulty(String difficulty) {
        this.difficulty = difficulty;
    }
    
    public boolean isIgnoreWall() {
        return ignoreWall;
    }

    public void setIgnoreWall(boolean ignoreWall) {
        this.ignoreWall = ignoreWall;
    }
    
    public boolean isGreenCollected() {
        return greenCollected;
    }

    public void setGreenCollected(boolean greenCollected) {
        this.greenCollected = greenCollected;
    }
    
  
    public boolean isWallRemoved() {
        return wallRemoved;
    }

    public void setWallRemoved(boolean wallRemoved) {
        this.wallRemoved = wallRemoved;
    }

    public boolean isGreenChecked() {
        return greenChecked;
    }

    public void setGreenChecked(boolean greenChecked) {
        this.greenChecked = greenChecked;
    }


    @Override
    public void keyTyped(KeyEvent e) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void keyPressed(KeyEvent e) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void keyReleased(KeyEvent e) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton homeScreen;
    private javax.swing.JLabel winLabel;
    // End of variables declaration//GEN-END:variables
}

